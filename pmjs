#! /usr/bin/env python3
# @file         pmjs - PythonMonkey REPL
# @author       Wes Garland, wes@distributive.network
# @date         June 2023

import sys, os, readline, signal, getopt
import pythonmonkey as pm
globalThis = pm.eval("globalThis")

if (os.getenv('PMJS_PATH')):
    requirePath = list(map(os.path.abspath, os.getenv('PMJS_PATH').split(':')))
else:
    requirePath = [];

pm.eval("""'use strict';
const cmds = {};

cmds.help = function help() {
  return '.' +
`exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

Press Ctrl+C to abort current expression, Ctrl+D to exit the REPL`
};

cmds.exit = python.exit;

/**
 * Handle a .xyz repl command. Invokes function cmds[XXX], passing arguments that the user typed as the
 * function arguments. The function arguments are space-delimited arguments; arguments surrounded by
 * quotes can include spaces, similar to how bash parses arguments. Argument parsing cribbed from 
 * stackoverflow user Tsuneo Yoshioka, question 4031900.
 *
 * @param {string} cmdLine     the command the user typed, without the leading .
 * @returns {string} to display
 */
globalThis.replCmd = function replCmd(cmdLine)
{
  const cmdName = (cmdLine.match(/^[^ ]+/) || ['help'])[0];
  const args = cmdLine.slice(cmdName.length).trim();
  const argv = args.match(/\\\\?.|^$/g).reduce((p, c) => {
        if (c === '"')
          p.quote ^= 1;
        else if (!p.quote && c === ' ')
          p.a.push('');
        else
          p.a[p.a.length-1] += c.replace(/\\\\(.)/,"$1");
        return  p;
    }, {a: ['']}).a;

  if (!cmds.hasOwnProperty(cmdName))
    return `Invalid REPL keyword`;
  return cmds[cmdName].apply(null, argv);
}

/** Return String(val) surrounded by appropriate ANSI escape codes to change the console text colour. */
function colour(colourCode, val)
{
  const esc=String.fromCharCode(27);
  return `${esc}[${colourCode}m${val}${esc}[0m`
}

/** 
 * Format result more intelligently than toString. Inspired by Node.js util.inspect, but far less 
 * capable.
 */
globalThis.formatResult = function formatResult(result)
{
  switch (typeof result)
  {
    case 'undefined':
      return colour(90, result);
    case 'function':
      return colour(36, result);
    case 'string':
      return colour(32, `'${result}'`);
    case 'boolean':
    case 'number':
      return colour(33, result);
    case 'object':
      if (result instanceof Date)
        return colour(35, result.toISOString());
      if (result instanceof Error)
      {
        const error = result;
        const LF = String.fromCharCode(10);
        const stackEls = error.stack
                         .split(LF)
                         .filter(a => a.length > 0)
                         .map(a => `    ${a}`);
        return (`${error.name}: ${error.message}` + LF
          + stackEls[0] + LF
          + colour(90, stackEls.slice(1).join(LF))
        );
      }
      return JSON.stringify(result);
    default:
      return colour(31, `<unknown type ${typeof result}>${result}`);
  }
}

/**
 * Evaluate a complete statement, built by the Python readline loop.
 */
globalThis.replEval = function replEval(statement)
{
  const indirectEval = eval;
  try
  {
    const result = indirectEval(`${statement}`);
    return formatResult(result);
  }
  catch(error)
  {
    return formatResult(error);
  }
}
""");

def repl():
    """
    Start a REPL to evaluate JavaScript code in the extra-module environment. Multi-line statements and
    readline history are supported. ^C support is sketchy. Exit the REPL with ^D or ".quit".
    """
    
    print('Welcome to PythonMonkey v' + pm.__version__ +'.')
    print('Type ".help" for more information.')
    readline.parse_and_bind('set editing-mode emacs')
    histfile = os.getenv('PMJS_REPL_HISTORY') or os.path.expanduser('~/.pmjs_history')
    if (os.path.exists(histfile)):
        readline.read_history_file(histfile)

    got_sigint = 0
    statement = ''
    readline_skip_chars = 0

    def quit():
        """
        Quit the REPL, writing history
        """
        readline.write_history_file(histfile)
        sys.exit(0)
    globalThis.python.exit = sys.exit

    def sigint_handler(signum, frame):
        """
        Handle ^C by aborting the entry of the current statement and quitting when double-struck.
        """
        nonlocal got_sigint
        nonlocal statement
        nonlocal readline_skip_chars

        got_sigint = got_sigint + 1
        if (got_sigint == 1 and statement == "" and readline.get_line_buffer() == ""):
            sys.stdout.write("\n(To exit, press Ctrl+C again or Ctrl+D or type .exit)")
        elif (got_sigint > 1):
            quit()

        sys.stdout.write("\n> ")
        readline_skip_chars = len(readline.get_line_buffer())
        statement = ""
    signal.signal(signal.SIGINT, sigint_handler)

    # Main Loop
    #
    # Read lines entered by the user and collect them in a statement. Once the statement is a candiate
    # for JavaScript evaluation (determined by pm.isCompilableUnit(), send it to replEval(). Statements
    # beginning with a . are interpreted as REPL commands and sent to replCmd().
    #
    # Beware - extremely tricky interplay between readline and the SIGINT handler. This is largely because we
    # we can't clear the pending line buffer, so we have to fake it by re-displaying the prompt and subtracting
    # characters. Another complicating factor is that the handler will suspend and resume readline, but there
    # is no mechanism to force readline to return before the user presses enter.
    #
    while got_sigint < 2:
        try:
            if (statement == ""):
                statement = input('> ')[readline_skip_chars:]
            readline_skip_chars = 0
            
            if (len(statement) == 0):
                continue
            if (statement[0] == '.'):
                print(globalThis.replCmd(statement[1:]))
                continue
            if (pm.isCompilableUnit(statement)):
                print(globalThis.replEval(statement))
                statement = ""
                got_sigint = 0
            else:
                got_sigint = 0
                # This loop builds a multi-line statement, but if the user hits ^C during this build, we
                # abort the statement. The tricky part here is that the input('... ') doesn't quit when
                # SIGINT is received, so we have to patch things up so that the next-entered line is
                # treated as the input at the top of the loop.
                while (got_sigint == 0):
                    more = input('... ')[readline_skip_chars:]
                    readline_skip_chars = 0
                    if (got_sigint > 0):
                        got_sigint = 0
                        statement = more
                        break
                    statement = statement + '\n' + more
                    if (pm.isCompilableUnit(statement)):
                        print(globalThis.replEval(statement))
                        statement = ""
                        break
        except EOFError:
            print()
            quit()


def usage():
    print("""Usage: pmjs [options] [ script.js ] [arguments]

Options:
  -                    script read from stdin (default if no file name is provided, interactive mode if a tty)
  --                   indicate the end of node options
  -e, --eval=...       evaluate script
  -h, --help           print pnode command line options (currently set)
  -i, --interactive    always enter the REPL even if stdin does not appear to be a terminal
  -p, --print [...]    evaluate script and print result
  -r, --require...     module to preload (option can be repeated)
  -v, --version        print PythonMonkey version
  
Environment variables:
TZ                            specify the timezone configuration
PMJS_PATH                     ':'-separated list of directories prefixed to the module search path
PMJS_REPL_HISTORY             path to the persistent REPL history file"""
    )

def initGlobalThis():
    """
    Initialize globalThis for for pmjs use in the extra-module context (eg -r, -e, -p). This context
    needs a require function which resolve modules relative to the current working directory at pmjs
    launch. The global require is to the JS function using a trick iinstead of a JS-wrapped-Python-wrapped function
    """
    require = pm.createRequire(os.getcwd() + '/__pmjs_virtual__', requirePath)
    globalThis.require = require

    argvBuilder = require(os.path.dirname(__file__) + "/pmjs-lib/global-init").setArguments() # module load has side-effects
    for arg in sys.argv:
        argvBuilder(arg); # list=>Array not working yet

def main():
    """
    Main program entry point
    """
    enterRepl = sys.stdin.isatty()
    forceRepl = False
    initGlobalThis()
    global requirePath
    
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hie:p:r:v", ["help", "eval=", "print=", "require=", "version"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err)  # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o in ("-v", "--version"):
            print(pm.__version__)
            sys.exit()
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-i", "--interactive"):
            forceRepl = True
        elif o in ("-e", "--eval"):
            pm.eval(a)
            enterRepl = False
        elif o in ("-p", "--print"):
            print(pm.eval(a))
            enterRepl = False
        elif o in ("-r", "--require"):
            pm.eval('require')(a)
        else:
            assert False, "unhandled option"

    if (len(args) > 0):
        pm.runProgramModule(args[0], args, requirePath)
    elif (enterRepl or forceRepl):
        repl()

if __name__ == "__main__":
    main()

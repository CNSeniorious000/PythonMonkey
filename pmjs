#! /usr/bin/env python3
# @file         pmjs - PythonMonkey REPL
# @author       Wes Garland, wes@distributive.network
# @date         June 2023

import sys, os, readline, signal, getopt
import pythonmonkey as pm

globalThis = pm.eval("globalThis;")
globalThis.python.write = sys.stdout.write
require = pm.createRequire(os.getcwd() + '/__pmjs__')
argvBuilder = require(os.path.dirname(__file__) + "/pmjs-lib/global-init").setArguments();
for arg in sys.argv:
    argvBuilder(arg); # list=>Array not working yet

pm.eval("""'use strict';
const cmds = {};

cmds.help = function help() {
  return '' +
`.exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

Press Ctrl+C to abort current expression, Ctrl+D to exit the REPL`
};

cmds.exit = python.exit;

/**
 * Handle a .XXX command. Invokes function cmds[XXX], passing arguments that the user typed
 * as the function arguments. The function arguments space-delimited arguments; arguments
 * surrounded by quotes can include spaces, similar to how bash parses arguments. Argument
 * parsing cribbed from stackoverflow user Tsuneo Yoshioka, question 4031900.
 *
 * @param {string} cmdLine     the command the user typed, without the leading .
 * @returns {string} to display
 */
globalThis.replCmd = function replCmd(cmdLine)
{
  const cmdName = (cmdLine.match(/^[^ ]+/) || ['help'])[0];
  const args = cmdLine.slice(cmdName.length).trim();
  const argv = args.match(/\\\\?.|^$/g).reduce((p, c) => {
        if (c === '"')
          p.quote ^= 1;
        else if (!p.quote && c === ' ')
          p.a.push('');
        else
          p.a[p.a.length-1] += c.replace(/\\\\(.)/,"$1");
        return  p;
    }, {a: ['']}).a;

  if (!cmds.hasOwnProperty(cmdName))
    return `Invalid REPL keyword`;
  return cmds[cmdName].apply(null, argv);
}

/** Return String(val) surrounded by appropriate ANSI escape codes to change the console text colour. */
function colour(colourCode, val)
{
  const esc=String.fromCharCode(27);
  return `${esc}[${colourCode}m${val}${esc}[0m`
}

/** 
 * Format result more intelligently than toString. Inspired by Node.js util.inspect, but far less 
 * capable.
 */
globalThis.formatResult = function formatResult(result)
{
  switch (typeof result)
  {
    case 'undefined':
      return colour(90, result);
    case 'function':
      return colour(36, result);
    case 'string':
      return colour(32, `'${result}'`);
    case 'boolean':
    case 'number':
      return colour(33, result);
    case 'object':
      if (result instanceof Date)
        return colour(35, result.toISOString());
      if (result instanceof Error)
      {
        const error = result;
        const LF = String.fromCharCode(10);
        const stackEls = error.stack
                         .split(LF)
                         .filter(a => a.length > 0)
                         .map(a => `    ${a}`);
        return (`${error.name}: ${error.message}` + LF
          + stackEls[0] + LF
          + colour(90, stackEls.slice(1).join(LF))
        );
      }
      return JSON.stringify(result);
    default:
      return colour(31, `<unknown type ${typeof result}>${result}`);
  }
}

/**
 * Evaluate a complete statement, built by the Python readline loop.
 */
globalThis.replEval = function replEval(statement)
{
  const indirectEval = eval;
  try
  {
    const result = indirectEval(`${statement}`);
    return formatResult(result);
  }
  catch(error)
  {
    return formatResult(error);
  }
}
""");

readline.parse_and_bind('set editing-mode emacs')
histfile = os.getenv('PMJS_REPL_HISTORY') or os.path.expanduser('~/.pmjs_history')
if (os.path.exists(histfile)):
    readline.read_history_file(histfile)

def quit():
     readline.write_history_file(histfile)
     sys.exit(0)
globalThis.python.exit = quit

got_sigint = 0
building_statement = False

# Try to handle ^C by aborting the entry of the current line and quitting when double-struck. Note that
# does not currently work properly because there doesn't seem to be an easy way to abort data entry via
# input() via gnu readline in Python.
def sigint_handler(signum, frame):
    global got_sigint
    global building_statement
    got_sigint = got_sigint + 1
    if (got_sigint == 1 and building_statement == False):
        print('(To exit, press Ctrl+C again or Ctrl+D or type .exit)')
    if (got_sigint > 1 and building_statement == False):
        quit()
    readline.redisplay()
signal.signal(signal.SIGINT, sigint_handler)

def repl():
    """
    Read lines entered by the user and collect them in a statement. Once the statement is a candiate for
    JavaScript evaluation (determined by pm.isCompilableUnit(), send it to replEval(). Statement beginning
    with a . are interpreted as REPL commands and sent to replCmd().
    """
    print('Welcome to PythonMonkey v' + pm.__version__ +'.')
    print('Type ".help" for more information.')
    global got_sigint
    
    while got_sigint < 2:
        try:
            building_statement = False
            statement = input('> ')
            
            if (len(statement) == 0):
                continue
            if (statement[0] == '.'):
                print(globalThis.replCmd(statement[1:]))
                continue
            if (pm.isCompilableUnit(statement)):
                print(globalThis.replEval(statement))
                got_sigint = 0
            else:
                building_statement = True
                got_sigint = 0
                while (got_sigint == 0):
                    more = input('... ')
                    statement = statement + '\n' + more
                    if (pm.isCompilableUnit(statement)):
                        print(globalThis.replEval(statement))
                        break
                    got_sigint = 0
                    building_statement = False
        except EOFError:
            print()
            quit()


def usage():
    print("""Usage: pmjs [options] [ script.js ] [arguments]

Options:
  -                    script read from stdin (default if no file name is provided, interactive mode if a tty)
  --                   indicate the end of node options
  -e, --eval=...       evaluate script
  -h, --help           print pnode command line options (currently set)
  -i, --interactive    always enter the REPL even if stdin does not appear to be a terminal
  -p, --print [...]    evaluate script and print result
  -r, --require...     module to preload (option can be repeated)
  -v, --version        print PythonMonkey version
  
Environment variables:
TZ                            specify the timezone configuration
PMJS_PATH                     ':'-separated list of directories prefixed to the module search path
PMJS_REPL_HISTORY             path to the persistent REPL history file"""
          )

def main():
    """
    Main program entry point
    """
    enterRepl = sys.stdin.isatty()
    forceRepl = False
    
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hie:p:r:v", ["help", "eval=", "print=", "require=", "version"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err)  # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o in ("-v", "--version"):
            print(pm.__version__)
            sys.exit()
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-i", "--interactive"):
            forceRepl = True
        elif o in ("-e", "--eval"):
            pm.eval(a)
            enterRepl = False
        elif o in ("-p", "--print"):
            print(pm.eval(a))
            enterRepl = False
        elif o in ("-r", "--require"):
            pm.eval('require')(a)
        else:
            assert False, "unhandled option"

    if (len(args) > 0):
        fileHnd = open(args[0], "r", encoding='utf-8')
        programCode = fileHnd.read()
        fileHnd.close()
        pm.eval(programCode)
    elif (enterRepl or forceRepl):
        repl()

if __name__ == "__main__":
    main()

    
